(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{474:function(e,v,t){"use strict";t.r(v);var s=t(3),_=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"为什要使用-diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什要使用-diff-算法"}},[e._v("#")]),e._v(" 为什要使用 diff 算法")]),e._v(" "),v("p",[e._v("diff 算法的使用要先从 vue 框架的设计说起，从范式角度来看，框架可以设计成命令式或声明式，权衡了性能和可维护性 vue 选择声明式的设计方案。")]),e._v(" "),v("h3",{attrs:{id:"命令式和声明式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#命令式和声明式"}},[e._v("#")]),e._v(" 命令式和声明式")]),e._v(" "),v("p",[e._v("命令式：代码本身描述的是“做事的过程”，在代码开发的时候，我们需要维护实现目标的整个过程，包括要手动完成 DOM 元素的创建、更新、删除等工作。如：Jquery 就是典型的命令式框架.\n声明式：更加关注结果，代码展示的就是我们要的结果，看上去更加直观，至于做事儿的过程，并不需要我们关心.\n从上面可以看出声明式的可维护性高于命令式，心智负担也小于命令式，但性能比命令式要差。\n命令式代码的更新性能消耗 = 直接修改的性能消耗，\n声明式 = 直接修改 + 找出差异的性能消耗。\n那么我们只要能把找出差异的性能消耗最小化，就可以让声明式的消耗无限接近命令式。这个时候我们就要使用虚拟 dom 和 diff 算法了")]),e._v(" "),v("h3",{attrs:{id:"什么是虚拟-dom-和-diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟-dom-和-diff-算法"}},[e._v("#")]),e._v(" 什么是虚拟 DOM 和 diff 算法")]),e._v(" "),v("p",[e._v("虚拟 DOM 就是用来表示真实 dom 的对象，vue 通过模版编译生成虚拟 DOM 树，然后在通过渲染器渲染成真实 DOM,当数据更新时，产生新的虚拟 dom 树，如果直接用新的虚拟 DOM 树生成真实 DOM 并不是最优的方法。为了进一步降低找出差异的性能的性能消耗，就要使用 diff 算法。Diff 算法是一种对比算法。对比两者是旧虚拟 DOM 和新虚拟 DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，实现精准地更新真实 DOM。")]),e._v(" "),v("p",[e._v("vue2 采用了"),v("strong",[e._v("双端 diff 算法")]),e._v("。核心方法是"),v("strong",[e._v("updateChildren")]),e._v(",通过"),v("em",[e._v("新前与旧前")]),e._v("、"),v("em",[e._v("新后与旧后")]),e._v("、"),v("em",[e._v("新后与旧前")]),e._v("、"),v("em",[e._v("新前与旧后")]),e._v("、"),v("em",[e._v("暴力比对")]),e._v("5 种查找。\n新前：newChildren 中所有未处理的第一个节点\n新后：newChildren 中所有未处理的最后一个节点\n旧前：oldChildren 中所有未处理的第一个节点\n旧后：oldChildren 中所有未处理的最后一个节点")]),e._v(" "),v("p",[e._v("在具体介绍前我们还需要了解 isSameVnode 这个用来对比两个节点是否相同的方法")]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/vue2.png",alt:""}})]),e._v(" "),v("h2",{attrs:{id:"vue3-快速-diff-算法的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-快速-diff-算法的实现"}},[e._v("#")]),e._v(" vue3 快速 diff 算法的实现")]),e._v(" "),v("p",[v("strong",[v("em",[e._v("注：下边所讲 diff 算法是 vuejs 设计与开发书的版本，与源码版有些差别，但核心部分是一样的，可去 mini-vue 查看源码版")])])]),e._v(" "),v("p",[e._v("vue3 使用了"),v("code",[e._v("快速diff算法")]),e._v("，核心方法是"),v("code",[e._v("patchKeyedChildren")]),e._v(",首先是借鉴了纯文本 diff 算法中的预处理思路,处理新旧两个组子节点中相同的前置节点和后置节点。处理完后，如果剩余节点无法简单的通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构建出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。")]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/vue3.png",alt:""}})])])}),[],!1,null,null,null);v.default=_.exports}}]);