(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{475:function(t,v,_){"use strict";_.r(v);var e=_(3),s=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"解释一下什么是闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解释一下什么是闭包"}},[t._v("#")]),t._v(" 解释一下什么是闭包 ?")]),t._v(" "),v("p",[t._v("闭包：就是能够读取外层函数内部变量的函数。")]),t._v(" "),v("p",[t._v("闭包需要满足三个条件：")]),t._v(" "),v("p",[t._v("访问所在作用域；")]),t._v(" "),v("p",[t._v("函数嵌套；")]),t._v(" "),v("p",[t._v("在所在作用域外被调用 。")]),t._v(" "),v("p",[t._v("优点： 可以重复使用变量，并且不会造成变量污染 。")]),t._v(" "),v("p",[t._v("缺点： 会引起内存泄漏")]),t._v(" "),v("p",[t._v("使用闭包的注意点：")]),t._v(" "),v("p",[t._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。")])])}),[],!1,null,null,null);v.default=s.exports}}]);