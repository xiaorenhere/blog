(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{468:function(t,s,a){"use strict";a.r(s);var o=a(3),n=Object(o.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"说一下-es6-中你熟悉的一些内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说一下-es6-中你熟悉的一些内容"}},[t._v("#")]),t._v(" 说一下 ES6 中你熟悉的一些内容 ?")]),t._v(" "),s("p",[t._v("1.class 类的继承 ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念")]),t._v(" "),s("p",[t._v("2.async、await 使用 async/await, 搭配 promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成")]),t._v(" "),s("p",[t._v("3.Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大")]),t._v(" "),s("p",[t._v("3.Symbol 是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的")]),t._v(" "),s("p",[t._v("5.Proxy 代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情\n原型就是一个为对象实例定义了一些公共属性和公共方法的对象模板。\n对象之间的继承关系通过构造函数的 prototype 指向父类对象，直到指向 Object 对象为止形成的指向链条。\n通俗讲： 原型链是原型对象创建过程的历史记录。\n注：在 javascript 中，所有的对象都拥有一个"),s("strong",[t._v("proto")]),t._v("属性指向该对象的原型（prototype) 。")]),t._v(" "),s("p",[t._v("6.Set 是类似于数组的数据集合，无序，插入删除速度快，元素不重复，查找速度快。")]),t._v(" "),s("p",[t._v("7.Map 是一个类似对象的数据结构，和对象不同的在于它的 key 可以是任意类型，但是对象只能使用")]),t._v(" "),s("p",[t._v("8.string 和 symbol 类型，Map 的存储关联性更强")]),t._v(" "),s("p",[t._v("9.生成器函数可以进行阻断函数执行的过程，通过传参可以传入新的值进入函数继续执行，可以用于将异步变为阻塞式同步")])])}),[],!1,null,null,null);s.default=n.exports}}]);